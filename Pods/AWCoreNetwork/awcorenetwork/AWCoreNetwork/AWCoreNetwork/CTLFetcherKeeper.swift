//
//  CTLFetcherService.swift
//  AWCoreNetwork
//
//  Copyright Â© 2016 VMware, Inc. All rights reserved. This product is protected
//  by copyright and intellectual property laws in the United States and other
//  countries as well as by international treaties. VMware products are covered
//  by one or more patents listed at http://www.vmware.com/go/patents.
//


import Foundation


/**
    This class provides convenient functions to create a properly configured fetcher object and
    maintains a very lightweight management over those created fetcher objects.

    For best performance and convenient usage, fetchers should be generated by a common
    CTLSessionFetcherKeeper instance, like

        _fetcherKeeper = CTLSessionFetcherKeeper()
        let myFirstFetcher = _fetcherKeeper.fetcherWithRequest(request1)
        let mySecondFetcher = _fetcherKeeper.fetcherWithRequest(request2)
 */
open class CTLSessionFetcherKeeper: NSObject {
    fileprivate var _sessionDelegate: CTLSessionDelegateProtocol = CTLSessionDelegate()
    open var sessionDelegate: CTLSessionDelegateProtocol {
        set(delegate) {
            CTLSynchronizer.synchronized {
                self._sessionDelegate = delegate
            }
        }
        get {
            var ret: CTLSessionDelegateProtocol? = nil
            CTLSynchronizer.synchronized {
                ret = self._sessionDelegate
            }
            return ret!
        }
    }

    fileprivate var _authorizer: CTLAuthorizationProtocol?
    var authorizer: CTLAuthorizationProtocol? {
        set(authorizer) {
            CTLSynchronizer.synchronized {
                self._authorizer = authorizer
            }
        }
        get {
            var ret: CTLAuthorizationProtocol? = nil
            CTLSynchronizer.synchronized {
                ret = self._authorizer
            }
            return ret
        }
    }
    
    fileprivate var _validator: CTLResponseValidationProtocol?
    var validator: CTLResponseValidationProtocol? {
        set(validator) {
            CTLSynchronizer.synchronized {
                self._validator = validator
            }
        }
        get {
            var ret: CTLResponseValidationProtocol? = nil
            CTLSynchronizer.synchronized {
                ret = self._validator
            }
            return ret
        }
    }

    fileprivate var _callbackQueue: DispatchQueue
    var callbackQueue: DispatchQueue {
        set(callbackQ) {
            CTLSynchronizer.synchronized {
                self._callbackQueue = callbackQ
            }
        }
        get {
            var ret: DispatchQueue? = nil
            CTLSynchronizer.synchronized {
                ret = self._callbackQueue
            }
            return ret!
        }
    }

    fileprivate var _configuration: URLSessionConfiguration? = nil
    open var configuration: URLSessionConfiguration? {
        set(conf) {
            CTLSynchronizer.synchronized {
                self._configuration = conf
            }
        }
        get {
            var ret: URLSessionConfiguration? = nil
            CTLSynchronizer.synchronized {
                ret = self._configuration
            }
            return ret
        }
    }

    fileprivate var _runningFetchersByHost:[String: [CTLSessionFetcher]] = [:]

    override init() {
        _callbackQueue = DispatchQueue(label: "AWCoreNetwork.CTLSessionFetcherKeeper.callback", attributes: [])
    }

    open func fetcherWithRequest(_ urlRequest: URLRequest) -> CTLSessionFetcher {
        let fetcher = CTLSessionFetcher(request: urlRequest, configuration: self.configuration)
        fetcher.keeper = self
        fetcher.callbackQueue = self.callbackQueue
        fetcher.authorizer = self.authorizer
        fetcher.responseValidator = self.validator
        fetcher.sessionDelegate = self.sessionDelegate
        return fetcher
    }

    open func stopAllFetch() {
        CTLSynchronizer.synchronized {
            let _ = self._runningFetchersByHost.map { (k: String, v: [CTLSessionFetcher]) -> [CTLSessionFetcher] in
                return v
            }.map { (fetchers: [CTLSessionFetcher]) -> Int in
                for fetcher in fetchers {
                    fetcher.stopFetch()
                }
                return 0
            }

            self._runningFetchersByHost.removeAll()
        }
    }

    open class func getFetchQueue(priority: UInt) -> DispatchQueue {
        return DispatchQueue.global(qos: .background)
    }

    internal func fetcherShouldBeginFetching(_ fetcher: CTLSessionFetcher) -> Bool {
        guard let url = fetcher.mutableRequest?.url else {
            return false
        }

        guard var host = url.host else {
            return false
        }

        if (host.characters.count == 0 && url.isFileURL) {
            host = "localhost"
        }

        if (host.characters.count == 0) {
            /// It might be DATA URIs
            return false
        }

        CTLSynchronizer.synchronized {
            guard self._runningFetchersByHost[host]?.index(of: fetcher) == nil else {
                return
            }
            
            self.addRunningFetcher(fetcher, host: host)
        }

        /**
            We'll save the host that serves as the key for this fetcher's array
            to avoid any chance of the underlying request changing, stranding
            the fetcher in the wrong array
         */
        fetcher.serviceHost = host

        return true
    }

    internal func fetcherDidStop(_ fetcher: CTLSessionFetcher) {
        CTLSynchronizer.synchronized {
            if (fetcher.serviceHost != nil) {
                var runningForHost = self._runningFetchersByHost[fetcher.serviceHost!]
                if let index = runningForHost?.index(of: fetcher) {
                    runningForHost?.remove(at: index)
                }
            }

        }

        fetcher.serviceHost = nil;
    }

    fileprivate func addRunningFetcher(_ fetcher: CTLSessionFetcher, host: String) {
        if var runningForHost = _runningFetchersByHost[host] {
            runningForHost.append(fetcher)
        } else {
            _runningFetchersByHost[host] = [fetcher]
        }
    }
}
